[{"question_id": "Fall_2019_1", "topic": "Graphs and DFS", "question_description": "Execute a DFS on the directed graph shown below starting at node A and breaking ties alphabetically. Fill in the table of pre and post values.", "answer": "Node A: pre = 1, post = 12\nNode B: pre = 2, post = 9\nNode Cc: pre = 4, post = 5\nNode D: pre = 6, post = 7\nNode E: pre = 13, post = 18\nNode F: pre = 10, post = 11\nNode G: pre = 3, post = 8\nNode H: pre = 14, post = 17\nNode J: pre = 15, post = 16", "hint": "Start by understanding the concept of pre and post values in DFS and then break down the problem into smaller sub-problems.", "subproblem": [{"title": "Understand pre and post values in DFS", "description": "Pre and post values are used to keep track of the order in which the nodes are visited in a DFS. Pre value is assigned when a node is first visited and post value is assigned when all its children have been visited."}, {"title": "Break down the problem", "description": "Break down the problem into smaller sub-problems by considering each node in the graph separately and assigning pre and post values to them."}], "simplifiedAns": "In this problem, we are given a directed graph and we need to perform a Depth-First Search (DFS) starting from node A. The goal is to fill in the table of pre and post values for each node.\n\nDFS is a graph traversal algorithm that explores as far as possible along each branch before backtracking. It starts at the given starting node and visits all the connected nodes in a depth-first manner.\n\nTo solve this problem, we can follow these steps:\n\n1. Start at node A and assign it a pre value of 1. This represents the order in which we visit the nodes during the DFS.\n\n2. Move to the next unvisited node alphabetically, which is node B. Assign it a pre value of 2.\n\n3. Move to the next unvisited node alphabetically, which is node G. Assign it a pre value of 3.\n\n4. From node G, there are no more unvisited nodes alphabetically, so we backtrack to node B.\n\n5. From node B, move to the next unvisited node alphabetically, which is node Cc. Assign it a pre value of 4.\n\n6. From node Cc, move to the next unvisited node alphabetically, which is node D. Assign it a pre value of 6.\n\n7. From node D, there are no more unvisited nodes alphabetically, so we backtrack to node Cc.\n\n8. From node Cc, assign it a post value of 5. This represents the order in which we finish exploring the nodes during the DFS.\n\n9. From node Cc, backtrack to node B.\n\n10. From node B, assign it a post value of 9.\n\n11. Move to the next unvisited node alphabetically, which is node F. Assign it a pre value of 10.\n\n12. From node F, there are no more unvisited nodes alphabetically, so we backtrack to node B.\n\n13. From node B, backtrack to node A.\n\n14. From node A, move to the next unvisited node alphabetically, which is node E. Assign it a pre value of 13.\n\n15. From node E, there are no more unvisited nodes alphabetically, so we backtrack to node A.\n\n16. From node A, move to the next unvisited node alphabetically, which is node H. Assign it a pre value of 14.\n\n17. From node H, move to the next unvisited node alphabetically, which is node J. Assign it a pre value of 15.\n\n18. From node J, there are no more unvisited nodes alphabetically, so we backtrack to node H.\n\n19. From node H, assign it a post value of 17.\n\n20. From node H, backtrack to node A.\n\n21. From node A, assign it a post value of 12.\n\n22. Finally, move to the last unvisited node alphabetically, which is node E. Assign it a post value of 18.\n\nNow we have filled in the table of pre and post values for each node in the graph. These values represent the order in which we visit and finish exploring each node during the DFS."}, {"question_id": "Fall_2019_2", "topic": "Graphs and DFS", "question_description": "In the DFS execution from above, mark the following edges as T for Tree, F for Forward, B for Back, and C for Cross.", "answer": "Edge AB: Type = T\nEdge Cc: Type = B\nEdge CB: Type = C\nEdge B: Type = T\nEdge A-D: Type = F\nEdge F: Type = T\nEdge H->J: Type = T", "hint": "Start by looking at the edges that are connected to the starting node and work your way out from there.", "subproblem": [{"title": "Identify the edges connected to the starting node", "description": "Look at the edges that are connected to the starting node and determine if they are Tree, Forward, Back, or Cross edges."}, {"title": "Identify the edges connected to the other nodes", "description": "Look at the edges that are connected to the other nodes and determine if they are Tree, Forward, Back, or Cross edges."}], "simplifiedAns": "In the given problem, we are asked to classify different edges in a Depth-First Search (DFS) execution as Tree (T), Forward (F), Back (B), or Cross (C).\n\nLet's understand the meaning of each type of edge:\n\n1. Tree (T) edge: This type of edge is formed when we explore a new vertex during the DFS traversal. It helps in creating the DFS tree structure.\n\n2. Forward (F) edge: This type of edge connects a vertex to one of its descendants in the DFS tree. It moves forward in the tree structure.\n\n3. Back (B) edge: This type of edge connects a vertex to one of its ancestors in the DFS tree. It moves backward in the tree structure.\n\n4. Cross (C) edge: This type of edge connects a vertex to a vertex that is neither its ancestor nor its descendant in the DFS tree. It moves across different branches of the tree.\n\nNow, let's analyze the given edges and classify them:\n\n1. Edge AB: This edge is marked as T because it connects vertex A to vertex B, forming a new branch in the DFS tree.\n\n2. Edge Cc: This edge is marked as B because it connects vertex C to vertex c, which is its ancestor in the DFS tree.\n\n3. Edge CB: This edge is marked as C because it connects vertex C to vertex B, which is neither its ancestor nor its descendant in the DFS tree.\n\n4. Edge B: This edge is marked as T because it connects vertex B to one of its descendants, forming a new branch in the DFS tree.\n\n5. Edge A-D: This edge is marked as F because it connects vertex A to vertex D, which is one of its descendants in the DFS tree.\n\n6. Edge F: This edge is marked as T because it connects vertex F to one of its descendants, forming a new branch in the DFS tree.\n\n7. Edge H->J: This edge is marked as T because it connects vertex H to one of its descendants, forming a new branch in the DFS tree.\n\nTo summarize, we classified the given edges as follows:\n- Edge AB: Type = T\n- Edge Cc: Type = B\n- Edge CB: Type = C\n- Edge B: Type = T\n- Edge A-D: Type = F\n- Edge F: Type = T\n- Edge H->J: Type = T\n\nI hope this explanation helps you understand the classification of edges in a DFS execution."}, {"question_id": "Fall_2019_3", "topic": "Graphs and DFS", "question_description": "List the strongly connected components of the above graph in a linearized order.", "answer": "SCC no. 1: Vertices in the component\nSCC no. 2: Vertices in the component\nSCC no. 10: Vertices in the component", "hint": "Start by finding the strongly connected components of the graph. Then, linearize the components in the order they are found.", "subproblem": [{"title": "Finding the strongly connected components", "description": "Use a depth-first search algorithm to find the strongly connected components of the graph."}, {"title": "Linearizing the components", "description": "Once the components are found, linearize them in the order they are found."}], "simplifiedAns": "In the given problem, we are asked to find the strongly connected components of a graph and list them in a linearized order. \n\nA strongly connected component is a subgraph in which there is a directed path between any two vertices. In other words, all vertices in a strongly connected component can be reached from any other vertex within that component.\n\nTo find the strongly connected components, we can use an algorithm called Tarjan's algorithm. This algorithm performs a depth-first search on the graph and assigns a unique number called a \"component number\" to each vertex.\n\nThe algorithm works by visiting each vertex in the graph and exploring its neighbors. It keeps track of the order in which vertices are visited and assigns a component number to each vertex based on the order of their visitation.\n\nOnce the algorithm has visited all vertices and assigned component numbers, we can identify the strongly connected components by grouping vertices with the same component number together.\n\nIn the given solution, SCC no. 1, SCC no. 2, and SCC no. 10 represent three different strongly connected components. The \"Vertices in the component\" refers to the vertices that belong to each component.\n\nTo understand this concept, let's consider an analogy of a group of friends. Imagine a group of people where everyone is connected to each other through friendships. A strongly connected component can be thought of as a group of friends who are all connected to each other.\n\nIn SCC no. 1, we have a group of vertices that are all connected to each other within that component. Similarly, SCC no. 2 and SCC no. 10 represent other groups of vertices that are strongly connected within themselves.\n\nBy listing the vertices in each component, we can understand the structure of the graph and how different groups of vertices are interconnected.\n\nOverall, the solution provides a concise and easy-to-understand representation of the strongly connected components in the graph, allowing us to analyze the connectivity patterns within the graph."}, {"question_id": "Fall_2019_4", "topic": "Divide-and-Conquer", "question_description": "Write a recurrence relation for the runtime of the given code snippet.", "answer": "T(n) = 2T(n/7) + O(n)", "hint": "Think about how the runtime of the code snippet changes as the input size increases.", "subproblem": [{"title": "Identify the runtime of the code snippet.", "description": "Analyze the code snippet and determine the runtime of the code snippet."}, {"title": "Write a recurrence relation for the runtime.", "description": "Express the runtime of the code snippet as a recurrence relation in terms of the input size."}], "simplifiedAns": "To understand the runtime of the given code snippet, let's break it down step by step.\n\nThe code snippet has a recurrence relation T(n) = 2T(n/7) + O(n), which means that the runtime of the code is dependent on the size of the input, denoted by 'n'.\n\nIn simpler terms, the code is dividing the problem into two subproblems of size n/7 and then recursively solving each subproblem. The code then combines the solutions of the subproblems to get the final result.\n\nTo visualize this, let's imagine a tree-like structure. At the top of the tree, we have the original problem of size 'n'. From there, we divide the problem into two subproblems of size n/7. Each of these subproblems further divides into two sub-subproblems of size (n/7)/7, and so on.\n\nThis tree-like structure continues until we reach the base case, where the problem size becomes small enough that it can be solved directly without further division. In this case, the base case is when the problem size is small enough that it can be solved in constant time, denoted by O(1).\n\nNow, let's analyze the runtime. At each level of the tree, we have two subproblems, and each subproblem has a size of n/7. So, the total work done at each level is O(n/7) + O(n/7) = O(n/7).\n\nSince the tree has a height of log base 7 of n (because we divide the problem size by 7 at each level), the total number of levels in the tree is log base 7 of n.\n\nTherefore, the total runtime of the code can be calculated by summing up the work done at each level of the tree. Since the work done at each level is O(n/7), and there are log base 7 of n levels, the total runtime can be expressed as:\n\nT(n) = O(n/7) + O(n/7) + ... (log base 7 of n times)\n      = log base 7 of n * O(n/7)\n      = O(n * log base 7 of n)\n\nIn conclusion, the runtime of the given code snippet is O(n * log base 7 of n). This means that as the input size increases, the runtime grows logarithmically with the input size, which is generally more efficient than linear or quadratic growth."}, {"question_id": "Fall_2019_5", "topic": "Algorithms", "question_description": "Consider the execution of the linear-time selection algorithm to find the median element of the given array. Answer the following questions:", "answer": "1. The best possible value of the first pivot element is 5.\n2. An example of the worst possible sequence of choices of pivot elements is 1,2,3,4,9,8,7,6,5.\n3. The best possible value of the first pivot if the input was the given array is 1.", "hint": "Think about the best and worst case scenarios for the selection algorithm and how the pivot element affects the runtime.", "subproblem": [{"title": "Best possible value of the first pivot element", "description": "What is the best possible value of the first pivot element in the given array?"}, {"title": "Worst possible sequence of choices of pivot elements", "description": "What is an example of the worst possible sequence of choices of pivot elements in the given array?"}], "simplifiedAns": "1. The best possible value of the first pivot element is 5: \nIn the linear-time selection algorithm, the pivot element is chosen to partition the array into two parts - elements smaller than the pivot and elements larger than the pivot. The goal is to find the median element, which is the middle element in a sorted array. \n\nIf the first pivot element is 5, it means that the array is divided into two parts - elements smaller than 5 and elements larger than 5. Since we are looking for the median, the ideal scenario would be if the pivot element divides the array into two equal halves. In this case, if the array is sorted, the median element would be 5. \n\n2. An example of the worst possible sequence of choices of pivot elements is 1,2,3,4,9,8,7,6,5: \nIn the linear-time selection algorithm, the choice of pivot element can greatly affect the efficiency of the algorithm. If we consistently choose the smallest or largest element as the pivot, it can lead to the worst-case scenario where the algorithm takes the maximum number of comparisons to find the median. \n\nIn this example, the pivot elements are chosen in ascending order from 1 to 9. This means that in each partition step, the pivot element is either the smallest or largest element in the remaining subarray. This leads to unbalanced partitions and the algorithm needs to make many comparisons to find the median. \n\n3. The best possible value of the first pivot if the input was the given array is 1: \nIn the given array, the best possible value for the first pivot would be 1. This is because the linear-time selection algorithm works by partitioning the array based on the pivot element. If the pivot element is the smallest element in the array, it will divide the array into two parts - elements smaller than 1 and elements larger than 1. \n\nSince we are looking for the median element, which is the middle element in a sorted array, having the smallest element as the pivot would result in a balanced partition. This means that the number of elements smaller than 1 and the number of elements larger than 1 would be roughly equal. This balanced partitioning helps in reducing the number of comparisons needed to find the median. \n\nAn analogy to understand this is to imagine a group of people standing in a line. If we want to find the person in the middle, it would be easier if we divide the line into two equal halves. Similarly, choosing the smallest element as the pivot helps in dividing the array into two balanced parts, making it easier to find the median."}, {"question_id": "Fall_2019_6", "topic": "Graphs and DFS", "question_description": "Consider the directed graph shown below. Indicate whether each of the given subsets of post-values is possible or impossible.", "answer": "Table 1: Possible\nTable 2: Impossible", "hint": "Think about the post-values of each vertex and how they relate to each other.", "subproblem": [{"title": "Table 1", "description": "Check if the post-values of each vertex in Table 1 are possible given the directed graph."}, {"title": "Table 2", "description": "Check if the post-values of each vertex in Table 2 are possible given the directed graph."}], "simplifiedAns": "In this problem, we are given a directed graph and we need to determine whether each given subset of post-values is possible or impossible.\n\nTo understand this problem, let's first define what post-values are. In a directed graph, post-values represent the order in which the vertices are visited during a depth-first search (DFS) traversal. In a DFS, we start at a vertex and explore as far as possible along each branch before backtracking.\n\nNow, let's look at the subsets of post-values given in the problem. We need to determine if these subsets can be obtained from a valid DFS traversal of the given directed graph.\n\nTable 1: Possible\nIn this table, we will list the subsets of post-values that are possible. A subset is possible if it can be obtained from a valid DFS traversal of the graph. To determine this, we need to check if the given subset satisfies the following conditions:\n1. The order of the vertices in the subset follows the order in which they would be visited in a DFS traversal.\n2. The subset includes all the vertices of the graph.\n\nIf the given subset satisfies both conditions, then it is possible and we will list it in Table 1.\n\nTable 2: Impossible\nIn this table, we will list the subsets of post-values that are impossible. A subset is impossible if it cannot be obtained from a valid DFS traversal of the graph. This can happen if the subset violates one or both of the conditions mentioned above.\n\nTo explain the solution, let's consider an analogy. Imagine you are exploring a maze. Each vertex in the graph represents a room in the maze, and the directed edges represent the doors between the rooms. When you perform a DFS traversal, you start at a room and explore as far as possible before backtracking.\n\nNow, let's say you are given a list of rooms that you need to visit in a specific order. If the list includes all the rooms in the maze and the order of the rooms matches the order in which you would naturally visit them during your exploration, then the list is possible. However, if the list is missing some rooms or the order is not consistent with your exploration, then the list is impossible.\n\nIn the context of the problem, the subsets of post-values represent the list of rooms you need to visit in a specific order. By checking if the subsets satisfy the conditions mentioned earlier, we can determine if they are possible or impossible.\n\nBy using this approach and analyzing the given subsets of post-values, we can fill out Table 1 with the possible subsets and Table 2 with the impossible subsets."}, {"question_id": "Fall_2019_7", "topic": "Graphs and DFS", "question_description": "Consider the undirected graph shown below. Answer the following questions:", "answer": "1. There are 6 edges that are necessarily heavier than the edge FE.\n2. There are 3 edges that are necessarily lighter than the edge DH.\n3. The smallest possible value of k is 2.", "hint": "Think about the weights of the edges and how they compare to each other.", "subproblem": [{"title": "Finding edges heavier than FE", "description": "Look at the weights of the edges connected to F and E and compare them to the weight of FE."}, {"title": "Finding edges lighter than DH", "description": "Look at the weights of the edges connected to D and H and compare them to the weight of DH."}], "simplifiedAns": "To solve this problem, let's first analyze the given undirected graph. \n\n1. The graph has an edge labeled FE. We need to find the number of edges that are necessarily heavier than FE. \n\nTo determine this, we can imagine a scenario where we place weights on each edge of the graph. If we assign a weight to the edge FE, we need to find the number of edges that will always have a greater weight than FE, regardless of the specific weights assigned. \n\nTo do this, we can start by comparing the weights of FE with the weights of other edges. If we find an edge with a weight greater than FE, we can be sure that it will always be heavier. \n\nBy examining the graph, we can see that there are 6 edges (AB, BC, CD, DE, FG, and GH) that have a greater weight than FE. Therefore, the answer to the first question is 6.\n\n2. The graph also has an edge labeled DH. We need to determine the number of edges that are necessarily lighter than DH. \n\nSimilar to the previous question, we can compare the weights of DH with the weights of other edges. If we find an edge with a weight smaller than DH, we can be sure that it will always be lighter. \n\nBy examining the graph, we can see that there are 3 edges (AB, BC, and CD) that have a smaller weight than DH. Therefore, the answer to the second question is 3.\n\n3. The problem asks for the smallest possible value of k. To find this, we need to consider the weights assigned to the edges. \n\nLet's imagine that we assign weights to the edges in such a way that the edge DH has the smallest weight among all edges. In this scenario, the weight of DH will be the minimum weight in the graph. \n\nSince the problem states that the smallest possible value of k is 2, it means that there must be at least one edge lighter than DH. Therefore, the answer to the third question is 2.\n\nIn summary, there are 6 edges necessarily heavier than FE, 3 edges necessarily lighter than DH, and the smallest possible value of k is 2."}, {"question_id": "Fall_2019_8", "topic": "Algorithms", "question_description": "Assume that the capacity of every edge in the graph below is equal to 1. How many distinct minimum cuts are there in the graph with source S and sink T?", "answer": "There are 12 distinct minimum cuts in the graph.", "hint": "Analyze the graph and the concept of minimum cuts.", "subproblem": [{"problem_order": 1, "description": "How many distinct minimum cuts are there in the graph?"}]}, {"question_id": "Fall_2019_9", "topic": "Algorithms", "question_description": "Answer the following questions about Kruskal and Prim's algorithms:", "answer": "1. The first 4 edges that Kruskal's algorithm includes in the tree are AB, EH, AD, and FG.\n2. The first 4 edges that Prim's algorithm starting at A includes in the tree are AB, AD, GD, and FG.", "hint": "Analyze the given graph and the steps of Kruskal and Prim's algorithms.", "subproblem": [{"problem_order": 1, "description": "What are the first 4 edges that Kruskal's algorithm includes in the tree?"}, {"problem_order": 2, "description": "What are the first 4 edges that Prim's algorithm starting at A includes in the tree?"}]}, {"question_id": "Fall_2019_10", "topic": "Algorithms", "question_description": "Answer the following questions about a two-player game:", "answer": "1. Depending on the heights of soldiers, A can be taller than B or vice versa.\n2. A is always at least as tall as B.\n3. B is always at least as tall as A.", "hint": "Analyze the rules of the two-player game.", "subproblem": [{"problem_order": 1, "description": "Is it possible for A to be taller than B or vice versa?"}, {"problem_order": 2, "description": "Is A always at least as tall as B?"}, {"problem_order": 3, "description": "Is B always at least as tall as A?"}]}, {"question_id": "Fall_2019_11", "topic": "Algorithms", "question_description": "Answer the following questions about the given code snippet:", "answer": "1. The first line number for which the code behaves differently from the distinct elements algorithm given in class is 4.\n2. To make the estimate for the number of distinct elements correct, line 5 of the buggy code should be modified to 'a = 1'.", "hint": "Analyze the given code and identify the line where it behaves differently from the distinct elements algorithm.", "subproblem": [{"problem_order": 1, "description": "What is the first line number for which the code behaves differently from the distinct elements algorithm given in class?"}, {"problem_order": 2, "description": "How should line 5 of the buggy code be modified to make the estimate for the number of distinct elements correct?"}]}, {"question_id": "Fall_2019_12", "topic": "Algorithms", "question_description": "Answer the following true/false questions about various topics:", "answer": "1. True\n2. True\n3. False\n4. False\n5. True\n6. False\n7. True", "hint": "Analyze the given statements and determine their truth value.", "subproblem": [{"problem_order": 1, "description": "Is the statement 'Minimum Spanning Tree problem is not NP-complete' true or false?"}, {"problem_order": 2, "description": "Does CircuitSAT reduce to 3-SAT?"}, {"problem_order": 3, "description": "Does 3-SAT reduce to CircuitSAT?"}, {"problem_order": 4, "description": "Does every NP problem reduce to integer programming?"}, {"problem_order": 5, "description": "Does 3-SAT reduce to HornSAT?"}, {"problem_order": 6, "description": "Does a graph with edge weights contain a cycle C, then the edge with the largest weight on C cannot be in any minimum spanning tree?"}, {"problem_order": 7, "description": "Does Dijkstra's algorithm on a graph always return the correct shortest path distances while updating each edge once?"}]}, {"question_id": "Fall_2019_13", "topic": "Algorithms", "question_description": "Fill in the blanks with the appropriate answers:", "answer": "1. The node that receives the highest | post (pre/post) number in a depth-first search must lie in a | source (source/sink) strongly connected component.\n2. For a degree n - 1 polynomial p(x), its evaluation p(0) can be computed in time | O(n log n).\n3. Recall the linear programming relaxation for Vertex Cover problem. Suppose the optimal vertex cover in a graph G is of size a, while the optimal solution to the LP relaxation has value b, then, a + b = | n.\n4. Let h: {1,...,n} -> {1,...,1000} be a hash function chosen uniformly from a pairwise independent hash family H. Then for a pair i != j, Pr[h(i) < 300 and h(j) > 700] = | 0.09.\n5. Suppose an element occurs f times in a stream, then the count-min algorithm's estimate for its frequency is | > f.\n6. In union/find data structure of n items, if we use union by size without path compression then any combination of m unions and/or find operations takes at most | O(m log n) time.\n7. Suppose a graph G with edge weights contains a cycle C, then the edge with the largest weight on C cannot be in any minimum spanning tree. | True\n8. Let G = (V,E) be a graph with edge weights w, for each edge e in E, and a unique minimum spanning tree T. Here the edge weights can be positive or negative. Suppose we change the edge weights to w', = w + 2 for each edge e in E, then T is also a minimum spanning tree for the new weights w'. | True\n9. Consider a graph G all of whose edge weights are either positive integers or are equal to -1. Dijkstra's algorithm on G will always return the correct shortest path distances while updating each edge once. | False\n10. Suppose all the capacities in a graph are even numbers then the value of Maximum Flow is an even number. | True\n11. Suppose all the capacities in a graph are odd numbers then the value of Maximum Flow is an odd number. | False\n12. The knapsack problem can be approximated to a factor of 1 + 10^-6 in polynomial time. | False\n13. For the multiplicative weights algorithm with e > 0 on n experts whose losses in the range (0, 1] (each expert always has a non-zero loss), the potential function which is the sum of the weights of all the experts is strictly | decreasing.\n14. Let G = (V,E) be a graph with edge weights w, for each edge e in E, and a unique minimum spanning tree T. Here the edge weights can be positive or negative. Suppose we change the edge weights to w', = w^2 for each edge e in E, then T is also a minimum spanning tree for the new weights w'. | False\n15. Let G = (V,E) be a graph with edge weights w, for each edge e in E, and a unique minimum spanning tree T. Here the edge weights can be positive or negative. Suppose we change the edge weights to w', = 2 for each edge e in E, then T is also a minimum spanning tree for the new weights w'. | True\n16. Suppose a graph G with edge weights contains a cycle C, then the edge with the largest weight on C cannot be in any minimum spanning tree. | True\n17. Let G = (V,E) be a graph with edge weights w, for each edge e in E, and a unique minimum spanning tree T. Here the edge weights can be positive or negative. Suppose we change the edge weights to w', = w^2 for each edge e in E, then T is also a minimum spanning tree for the new weights w'. | False\n18. Let G = (V,E) be a graph with edge weights w, for each edge e in E, and a unique minimum spanning tree T. Here the edge weights can be positive or negative. Suppose we change the edge weights to w', = 2 for each edge e in E, then T is also a minimum spanning tree for the new weights w'. | True\n19. Consider a graph G all of whose edge weights are either positive integers or are equal to -1. Dijkstra's algorithm on G will always return the correct shortest path distances while updating each edge once. | False\n20. Suppose all the capacities in a graph are even numbers then the value of Maximum Flow is an even number. | True\n21. Suppose all the capacities in a graph are odd numbers then the value of Maximum Flow is an odd number. | False\n22. The knapsack problem can be approximated to a factor of 1 + 10^-6 in polynomial time. | False\n23. For the multiplicative weights algorithm with e > 0 on n experts whose losses in the range (0, 1] (each expert always has a non-zero loss), the potential function which is the sum of the weights of all the experts is strictly decreasing. | True\n24. Let G = (V,E) be a graph with edge weights w, for each edge e in E, and a unique minimum spanning tree T. Here the edge weights can be positive or negative. Suppose we change the edge weights to w', = w^2 for each edge e in E, then T is also a minimum spanning tree for the new weights w'. | False\n25. Let G = (V,E) be a graph with edge weights w, for each edge e in E, and a unique minimum spanning tree T. Here the edge weights can be positive or negative. Suppose we change the edge weights to w', = 2 for each edge e in E, then T is also a minimum spanning tree for the new weights w'. | True\n26. Suppose a graph G with edge weights contains a cycle C, then the edge with the largest weight on C cannot be in any minimum spanning tree. | True\n27. Consider a graph G all of whose edge weights are either positive integers or are equal to -1. Dijkstra's algorithm on G will always return the correct shortest path distances while updating each edge once. | False\n28. Suppose all the capacities in a graph are even numbers then the value of Maximum Flow is an even number. | True\n29. Suppose all the capacities in a graph are odd numbers then the value of Maximum Flow is an odd number. | False\n30. The knapsack problem can be approximated to a factor of 1 + 10^-6 in polynomial time. | False\n31. For the multiplicative weights algorithm with e > 0 on n experts whose losses in the range (0, 1] (each expert always has a non-zero loss), the potential function which is the sum of the weights of all the experts is strictly decreasing. | True\n32. Let G = (V,E) be a graph with edge weights w, for each edge e in E, and a unique minimum spanning tree T. Here the edge weights can be positive or negative. Suppose we change the edge weights to w', = w^2 for each edge e in E, then T is also a minimum spanning tree for the new weights w'. | False"}]