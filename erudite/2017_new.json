[{"question_id": "Spring2016_1", "topic": "Divide-and-Conquer", "question_description": "Use Fermat's Little Theorem with a base of a = 3 to show that 8 is not prime.", "answer": "FLT states that for all primes p, and bases 0 < a < p, a^(p-1) = 1 (mod p); since in this case, 3^(8-1) = 3^7 = 3*3^6 = 3*1 = 3 (mod 8), we know that 8 is not actually prime.", "hint": "Remember that Fermat's Little Theorem states that for all primes p, and bases 0 < a < p, a^(p-1) = 1 (mod p).", "subproblem": [{"title": "Calculate a^(p-1)", "description": "Calculate a^(p-1) for a given base a and prime p."}, {"title": "Check if a^(p-1) = 1 (mod p)", "description": "Check if a^(p-1) is equal to 1 (mod p) for a given base a and prime p."}], "simplifiedAns": "Sure! Let's break down the problem and solution step by step.\n\nThe problem states that we need to use Fermat's Little Theorem (FLT) with a base of a = 3 to show that 8 is not prime. \n\nFermat's Little Theorem (FLT) tells us that for all primes p, and bases 0 < a < p, a^(p-1) is congruent to 1 modulo p. \n\nIn this case, we are using a base of 3 and want to show that 8 is not prime. \n\nTo do this, we need to calculate 3^(8-1) modulo 8. \n\nSimplifying, we have 3^7 modulo 8. \n\nNow, let's use FLT to simplify further. FLT tells us that 3^(8-1) is congruent to 1 modulo 8. \n\nSo, 3^7 is congruent to 1 modulo 8. \n\nTo find the value of 3^7 modulo 8, we can break it down step by step. \n\nStarting with 3^1, we have 3 modulo 8. \n\nMultiplying by 3, we get 3^2 = 9 modulo 8, which is equivalent to 1 modulo 8. \n\nMultiplying by 3 again, we get 3^3 = 27 modulo 8, which is equivalent to 3 modulo 8. \n\nContinuing this pattern, we have 3^4 = 81 modulo 8, which is equivalent to 1 modulo 8. \n\nMultiplying by 3 one more time, we have 3^5 = 243 modulo 8, which is equivalent to 3 modulo 8. \n\nFinally, multiplying by 3 again, we have 3^6 = 729 modulo 8, which is equivalent to 1 modulo 8. \n\nSo, we can see that the pattern repeats every 2 powers of 3. \n\nTherefore, 3^7 is congruent to 3 modulo 8. \n\nSince 3^7 is not congruent to 1 modulo 8, we can conclude that 8 is not actually prime. \n\nIn simpler terms, Fermat's Little Theorem tells us that if a number is prime, then a^(p-1) is congruent to 1 modulo p. \n\nIn this case, we used a base of 3 and found that 3^7 is not congruent to 1 modulo 8. \n\nTherefore, we can conclude that 8 is not prime. \n\nAn analogy to understand this concept is to think of a lock and a key. \n\nIf a number is prime, it's like having a lock with a special key that fits perfectly and opens the lock. \n\nBut in the case of 8, the key (3^7) doesn't fit perfectly and doesn't open the lock. \n\nSo, we can say that 8 is not prime."}, {"question_id": "Spring2016_2", "topic": "Hashing", "question_description": "Given a prime p and a,b \u00e2\u02c6\u02c6 {0,...,p-1}, define the function h(x) = ax + b (mod p) where x \u00e2\u02c6\u02c6 {0,...,p-1}. Show that H = {h | a,b \u00e2\u02c6\u02c6 {0,...,p-1}} is a pairwise independent hash function family.", "answer": "For each x and y, h(x) = c and h(y) = d if and only if ax + b = c and ay + b = d. This is true if and only if a,b solve the system of equations ax + b = c and ay + b = d. We are guaranteed that the multiplicative inverses exist because p is prime, and we know x \u00e2\u2030\u00a0 y. Thus, there is only one value of a and one value of b that satisfy these equations, which are chosen independently at random: the probability of this occurring is 1/p^2.", "hint": "Remember that a prime number has no two distinct divisors. Think about how this property can be used to solve the problem.", "subproblem": [{"title": "Show that h(x) = ax + b (mod p) is a pairwise independent hash function family.", "description": "Show that for each x and y, h(x) = c and h(y) = d if and only if ax + b = c and ay + b = d. This is true if and only if a,b solve the system of equations ax + b = c and ay + b = d."}, {"title": "Show that the probability of this occurring is 1/p^2.", "description": "We are guaranteed that the multiplicative inverses exist because p is prime, and we know x \u00e2\u2030\u00a0 y. Thus, there is only one value of a and one value of b that satisfy these equations, which are chosen independently at random."}], "simplifiedAns": "In this problem, we are given a prime number 'p' and two numbers 'a' and 'b' which can take values from 0 to p-1. We need to show that the set of functions H, defined as h(x) = ax + b (mod p), where x can take values from 0 to p-1, forms a pairwise independent hash function family.\n\nTo prove this, let's consider two different inputs x and y. We want to show that if h(x) = c and h(y) = d, then it implies that ax + b = c and ay + b = d.\n\nNow, if ax + b = c and ay + b = d, we can rewrite these equations as ax = c - b and ay = d - b. Since p is prime, we are guaranteed that the multiplicative inverses of a exist. This means that for each value of x and y, there is a unique value of a that satisfies these equations.\n\nSince x is not equal to y, the values of ax and ay will be different. Therefore, the values of c - b and d - b will also be different. This implies that there is only one value of a and one value of b that can satisfy these equations, and they are chosen independently at random.\n\nTo understand this concept, let's consider an analogy. Imagine you have a box of different colored balls, and you want to randomly select two balls. Each ball represents a possible value of a and b. When you pick a ball for the first equation ax + b = c, you remove it from the box. Now, when you pick a ball for the second equation ay + b = d, you can only pick a ball that is still in the box. Since you have already removed the ball chosen for the first equation, you are guaranteed to pick a different ball for the second equation.\n\nTherefore, the probability of selecting the same values of a and b for both equations is 1 divided by the total number of possible values for a and b, which is p^2.\n\nIn conclusion, the set of functions H, defined as h(x) = ax + b (mod p), where x can take values from 0 to p-1, forms a pairwise independent hash function family. This means that for any two different inputs x and y, the probability of getting the same output values c and d is 1 divided by p^2."}, {"question_id": "Spring2016_3", "topic": "Zero-Sum Games", "question_description": "Alice and Bob play a game: each player chooses either X or Y. If both players pick X, Bob pays Alice $1. If both players pick Y, Bob pays Alice $2. Otherwise, Alice pays Bob $1.", "answer": "The optimal strategies for Alice and Bob are both (3/5, 2/5).", "hint": "Think about the payoff for each player when they choose X or Y.", "subproblem": [{"title": "Calculate Alice's payoff when she chooses X", "description": "Calculate the payoff for Alice when she chooses X and Bob chooses X, Y, or a mix of X and Y."}, {"title": "Calculate Bob's payoff when he chooses X", "description": "Calculate the payoff for Bob when he chooses X and Alice chooses X, Y, or a mix of X and Y."}], "simplifiedAns": "In this game, Alice and Bob have to choose between two options: X and Y. The outcome of the game depends on their choices. If both players choose X, Bob will give Alice $1. If both players choose Y, Bob will give Alice $2. However, if they choose different options, Alice will have to give Bob $1.\n\nTo find the best strategy, we need to determine the probabilities of Alice and Bob choosing X or Y. The optimal strategies for both players are to choose X with a probability of 3/5 (or 60%) and Y with a probability of 2/5 (or 40%).\n\nTo understand this, let's imagine a scenario where Alice and Bob are playing a game of rock-paper-scissors. If Alice always chooses rock with a probability of 60% and Bob always chooses paper with a probability of 40%, they would have the same optimal strategies as in this game.\n\nBy following these optimal strategies, both Alice and Bob maximize their expected payoffs in the long run. This means that on average, they will end up with the most money by choosing X 60% of the time and Y 40% of the time.\n\nOverall, the optimal strategies for Alice and Bob in this game are both to choose X with a probability of 3/5 and Y with a probability of 2/5. This ensures that they have the highest chances of winning and maximizing their expected payoffs."}, {"question_id": "Spring2016_4", "topic": "Reductions, Bipartite Matching", "question_description": "Circle the (unique) condition that would make the statement true: If B is NP-complete, then for any problem A \u00e2\u02c6\u02c6 NP, there exists a polynomial-time reduction from A to B.", "answer": "Always true: this is the definition of NP-hard, and all NP-complete problems are NP-hard.", "hint": "Remember that NP-hard is a stronger condition than NP-complete. Think about what it means for a problem to be NP-hard.", "subproblem": [{"title": "What is NP-hard?", "description": "NP-hard is a class of problems for which any problem in NP can be reduced to in polynomial time. It is a stronger condition than NP-complete."}, {"title": "What does it mean for a problem to be reduced?", "description": "Reducing a problem means transforming it into another problem. In this case, it means transforming a problem in NP into a problem that is NP-complete in polynomial time."}], "simplifiedAns": "The statement is asking us to identify the condition that would make it true that if problem B is NP-complete, then for any problem A in the class NP, there exists a polynomial-time reduction from A to B.\n\nTo understand this, let's first clarify some terms. NP-complete is a class of problems that are believed to be among the most difficult problems in computer science. A problem A is said to be in NP if there exists a non-deterministic polynomial-time algorithm that can verify a solution to A in polynomial time. A polynomial-time reduction is a way to transform one problem into another in such a way that a solution to the second problem can be used to solve the first problem efficiently.\n\nNow, the condition that makes the statement true is that all NP-complete problems are NP-hard. NP-hard is a class of problems that are at least as hard as the hardest problems in NP. In other words, if a problem B is NP-complete, it means that any problem A in NP can be reduced to B in polynomial time.\n\nTo understand this concept, let's imagine a scenario where you have a set of puzzles, each representing a problem. The NP-complete problems are like the most challenging puzzles in the set, and the NP problems are the easier puzzles. The condition states that if a puzzle B is NP-complete, then there exists a way to transform any puzzle A (from the easier set) into puzzle B, such that if you can solve puzzle B efficiently, you can also solve puzzle A efficiently.\n\nIn summary, the condition that makes the statement true is that all NP-complete problems are NP-hard. This means that if a problem B is NP-complete, then any problem A in NP can be reduced to B in polynomial time, allowing us to efficiently solve A using the solution to B."}, {"question_id": "Spring2016_5", "topic": "Linear Programming", "question_description": "For the following linear program, prove that the value of the optimal solution is at most 7/3 by finding the values of the dual variables y and yp.", "answer": "The values of the dual variables y and yp are 1/3 and 1/3, respectively.", "hint": "Start by writing down the dual problem and then use the complementary slackness conditions to find the values of the dual variables.", "subproblem": [{"title": "Write down the dual problem", "description": "Write down the dual problem of the given linear program and identify the dual variables."}, {"title": "Use complementary slackness conditions", "description": "Use the complementary slackness conditions to find the values of the dual variables y and yp."}], "simplifiedAns": "Sure! Let's start by understanding the problem and its context. In this linear program, we have a certain objective that we want to optimize (maximize or minimize) while satisfying a set of constraints. The objective and constraints are all linear equations or inequalities.\n\nNow, in order to prove that the value of the optimal solution is at most 7/3, we need to find the values of the dual variables y and yp. The dual variables are associated with the constraints of the linear program and provide information about the sensitivity of the objective function to changes in those constraints.\n\nIn this case, we are given that the values of the dual variables y and yp are 1/3 and 1/3, respectively. These values represent the rates at which the objective function would change if the corresponding constraints were relaxed or tightened.\n\nTo find the solution, we need to use these dual variables in conjunction with the primal problem (the original linear program) to determine the optimal solution. The primal problem consists of the objective function and the constraints.\n\nBy using the values of y and yp, we can calculate the optimal solution. The optimal solution is obtained by substituting the values of the dual variables into the primal problem and solving it.\n\nOnce we have the optimal solution, we can compare it to the value of 7/3. If the optimal solution is less than or equal to 7/3, then we have successfully proven that the value of the optimal solution is at most 7/3.\n\nTo understand this concept in a more relatable way, let's consider an analogy. Imagine you are a chef trying to optimize a recipe while working within certain constraints. The objective is to create the most delicious dish possible, and the constraints are the ingredients and cooking techniques available to you.\n\nThe dual variables y and yp can be thought of as the \"sensitivity\" of the recipe to changes in the constraints. For example, if you have a constraint that limits the amount of salt you can use, the dual variable associated with that constraint (y) would tell you how much the taste of the dish would change if you were allowed to use a little more or a little less salt.\n\nBy using the values of y and yp, you can adjust the recipe accordingly to find the optimal solution. And once you have the optimal solution, you can compare it to a desired outcome (in this case, 7/3) to see if it meets the criteria.\n\nI hope this explanation helps you understand the solution process in the context of the problem! Let me know if you have any further questions."}, {"question_id": "Spring2016_6", "topic": "Reductions, Bipartite Matching", "question_description": "What's wrong with the following reduction from 3SAT to Max Flow? Give a counterexample to show why this reduction does not hold.", "answer": "There is no constraint preventing both x and x from being set to true. One counterexample is (x1) \u00e2\u02c6\u00a7 (x3).", "hint": "Think about what happens when both x1 and x3 are set to true.", "subproblem": [{"title": "Understand the reduction from 3SAT to Max Flow", "description": "Understand how the 3SAT problem is reduced to a Max Flow problem and what the constraints are."}, {"title": "Find a counterexample", "description": "Find a 3SAT instance that does not satisfy the constraints of the Max Flow problem."}], "simplifiedAns": "The problem is that the given reduction from 3SAT to Max Flow does not consider the constraint that both x and x cannot be set to true at the same time. This means that the reduction fails to capture the essence of the original problem.\n\nTo understand this, let's consider the counterexample provided: (x1) \u2227 (x3). In this case, we have two clauses, (x1) and (x3), which both have only one literal. The reduction would create two nodes in the flow network, one for each literal, and connect them to the source node. Then, it would create two nodes for the clauses and connect them to the corresponding literals.\n\nHowever, since there is no constraint preventing both x1 and x3 from being set to true, the reduction fails to capture the fact that at least one of them should be false for the formula to be satisfied. In the Max Flow problem, this would mean that both literals can be assigned a flow value of 1, which would incorrectly satisfy the formula.\n\nTo fix this, we need to modify the reduction to include a constraint that prevents both x and x from being set to true simultaneously. One possible solution could be to introduce an additional node in the flow network that represents the constraint. This node would have an edge connected to both literals, and its capacity would be set to 1. This way, the Max Flow algorithm would ensure that only one of the literals can have a flow value of 1, satisfying the constraint.\n\nIn analogy, we can think of the reduction as trying to fit a square peg into a round hole. The original problem of 3SAT has a specific constraint that needs to be considered, but the reduction fails to capture it. By modifying the reduction, we can reshape the peg to fit the hole correctly, ensuring that the constraint is properly addressed."}, {"question_id": "Spring2016_7", "topic": "Greedy Algorithms", "question_description": "Tanya the TA has a stack of final exams, sorted by score. She wanted to show Prof Vazirani the top score, but Charles the clueless TA has split the stack as follows: he picked up the top i exams in the stack, and moved them to the bottom. Help Tanya find the exam with the maximum score again!", "answer": "Use the UNCYCLE algorithm to find the maximum value in the array.", "hint": "Think of the problem as a circular array and use the UNCYCLE algorithm to find the maximum value.", "subproblem": [{"title": "Split the stack", "description": "Split the stack into two parts, the top i exams and the rest of the exams."}, {"title": "Find the maximum value", "description": "Use the UNCYCLE algorithm to find the maximum value in the array."}], "simplifiedAns": "To solve this problem, we can use the UNCYCLE algorithm. This algorithm helps us find the maximum value in an array, even if the array has been split or rotated.\n\nIn the context of this problem, imagine the stack of exams as a circular track, like a race track. Each exam represents a runner on this track. Now, Charles, the clueless TA, has split the stack by moving the top i exams to the bottom. This is like moving the runners forward on the track.\n\nTo find the exam with the maximum score, we can use the UNCYCLE algorithm. Here's how it works:\n\n1. Start by assuming the first exam (or runner) has the maximum score. Let's call this exam \"MaxExam\" and its score \"MaxScore\".\n\n2. Iterate through the remaining exams (or runners) in the stack. Compare each exam's score with MaxScore.\n\n3. If an exam has a higher score than MaxScore, update MaxExam and MaxScore to the current exam's values.\n\n4. Continue this process until you have checked all the exams in the stack.\n\n5. At the end, MaxExam will represent the exam with the maximum score.\n\nNow, let's see how this algorithm works with an example:\n\nSuppose we have a stack of exams with scores [85, 92, 78, 95, 88] and Charles splits the stack by moving the top 2 exams to the bottom. So, the new order of exams becomes [78, 95, 88, 85, 92].\n\nWe start by assuming the first exam (78) has the maximum score. Then, we compare it with the next exam (95). Since 95 is greater than 78, we update MaxExam to the second exam (95) and MaxScore to 95.\n\nNext, we compare MaxScore (95) with the next exam (88). Since 95 is still greater, we don't update MaxExam or MaxScore.\n\nWe continue this process until we have checked all the exams. In this case, the last exam (92) has a higher score than MaxScore (95), so we update MaxExam to the last exam (92) and MaxScore to 92.\n\nFinally, we have found the exam with the maximum score, which is the last exam (92) in this case.\n\nSo, using the UNCYCLE algorithm, Tanya can find the exam with the maximum score even after Charles splits the stack."}, {"question_id": "Spring2016_8", "topic": "Dynamic Programming", "question_description": "You're going to be traveling this summer and you've listed your apartment on Airbnb. Due to your prime location, n guests have expressed interest in renting your apartment. Find an efficient algorithm to determine the maximum total value P, where P is the sum of the rewards you receive from renting your apartment to a subset of guests.", "answer": "Use the SUBLET algorithm to determine the maximum total value P.", "hint": "Think about how you can break down this problem into smaller subproblems that can be solved more easily.", "subproblem": [{"title": "Identify the guests who have expressed interest in renting your apartment.", "description": "Create a list of the guests who have expressed interest in renting your apartment and their associated rewards."}, {"title": "Find the maximum total value P.", "description": "Use the SUBLET algorithm to find the maximum total value P, which is the sum of the rewards you receive from renting your apartment to a subset of guests."}], "simplifiedAns": "To solve this problem, we can use the SUBLET algorithm. SUBLET stands for Subset Sum Problem with Limited Elements and Total. \n\nIn the context of this problem, the algorithm will help us determine the maximum total value (P) we can achieve by renting our apartment to a subset of guests. Each guest has a reward associated with them, and our goal is to maximize the sum of these rewards.\n\nHere's how the SUBLET algorithm works:\n\n1. First, we sort the list of guests in descending order based on their rewards. This step helps us prioritize the guests with higher rewards.\n\n2. We initialize a 2D array, let's call it \"dp,\" with dimensions (n+1) x (P+1), where n is the number of guests and P is the maximum total value we can achieve.\n\n3. We set the first row of the dp array to all zeros, as it represents the case where we have no guests to consider.\n\n4. We iterate through each guest, starting from the first one. For each guest, we iterate through each possible total value (p) from 1 to P.\n\n5. For each combination of guest and total value, we have two options:\n   a. Include the current guest: If the reward of the current guest is less than or equal to the current total value (p), we update the dp array by considering the maximum value between including the current guest's reward and the value obtained by excluding the current guest.\n   b. Exclude the current guest: In this case, we simply copy the value from the previous row of the dp array.\n\n6. After iterating through all guests and total values, the maximum total value (P) will be stored in the bottom-right cell of the dp array.\n\n7. To find the subset of guests that contribute to the maximum total value, we can backtrack through the dp array. Starting from the bottom-right cell, we check if the value in the current cell is equal to the value obtained by excluding the current guest. If not, it means the current guest was included, and we add them to our subset. We then move to the cell above and repeat the process until we reach the top-left cell.\n\nBy following the SUBLET algorithm, we can efficiently determine the maximum total value (P) and the subset of guests that contribute to it. This approach ensures that we consider all possible combinations and make optimal choices based on the rewards of the guests. It's like finding the best combination of guests that maximizes our overall benefit, similar to solving a puzzle where we need to select the right pieces to achieve the highest score."}, {"question_id": "Spring2016_9", "topic": "Greedy Algorithms", "question_description": "You are investing in stocks in the Delphi Exchange. The Delphi Exchange has only two stocks, and on each day you either stay with your current stock or sell all of your holdings and invest all your money in the other stock. On each day, the price of one stock goes down by 75% and the other stock doubles. There are 64 oracles in Delphi, who give their forecast for the change in stock prices for the next day. You are guaranteed that at least one oracle is always correct. Describe a strategy such that after 28 days, you are guaranteed to have at least $1000.", "answer": "Use the bold bluff strategy to guarantee a minimum of $1000 after 28 days.", "hint": "Think about how you can use the oracles' forecasts to your advantage.", "subproblem": [{"title": "Identify the oracles' forecasts", "description": "Look at the oracles' forecasts and identify which one is correct."}, {"title": "Use the bold bluff strategy", "description": "Use the bold bluff strategy to invest in the stock that will double in price and guarantee a minimum of $1000 after 28 days."}], "simplifiedAns": "In order to guarantee a minimum of $1000 after 28 days of investing in stocks in the Delphi Exchange, we can use a strategy called the bold bluff strategy. \n\nThe Delphi Exchange has two stocks, and each day we have the option to either stay with our current stock or sell all of our holdings and invest all our money in the other stock. The prices of the stocks change daily, with one stock decreasing by 75% and the other stock doubling in value.\n\nTo ensure a minimum of $1000 after 28 days, we will make use of the 64 oracles in Delphi who provide their forecasts for the next day's stock price changes. We are guaranteed that at least one oracle is always correct.\n\nHere's how the bold bluff strategy works:\n\n1. On the first day, we randomly choose one of the two stocks to invest in. It doesn't matter which one we choose at this point.\n\n2. For the next 27 days, we will follow the oracle's forecast for the next day's stock price change. If the oracle predicts that the stock we currently hold will increase in value, we will stay with our current stock. If the oracle predicts that the other stock will increase in value, we will sell all our holdings and invest all our money in the other stock.\n\n3. On the 28th day, regardless of the oracle's forecast, we will sell all our holdings and invest all our money in the stock that we have not invested in throughout the 28 days.\n\nBy following this strategy, we are guaranteed to have at least one correct oracle prediction throughout the 28 days. This means that on the 28th day, we will have invested in the stock that has consistently increased in value, while avoiding the stock that consistently decreased in value.\n\nUsing the bold bluff strategy, we can be confident that our investment will have grown significantly after 28 days, ensuring that we have at least $1000. This strategy takes advantage of the oracles' forecasts and the guaranteed correctness of at least one oracle to make informed decisions and maximize our profits.\n\nTo understand this strategy better, let's consider an analogy. Imagine you are playing a game of poker, and you have 64 opponents. Each opponent gives you their prediction for the next card to be drawn from the deck. You know that at least one opponent will always be correct. To increase your chances of winning, you decide to follow the prediction of the opponent who has been consistently correct throughout the game. By doing so, you are using their expertise to your advantage and increasing your chances of winning the game. Similarly, in the Delphi Exchange scenario, we are using the oracles' forecasts to make informed investment decisions and guarantee a minimum profit of $1000 after 28 days."}, {"question_id": "Spring2016_10", "topic": "Dynamic Programming", "question_description": "You are the captain of a ship, tasked with taking animals across the river. However, not all animals get along - some animals will attack each other. If the ith animal gets attacked, you have to pay the owner a fee of fj. If the ith animal makes it across the river without getting attacked, you receive a reward of rj. You want to know if there's a subset of animals you can take such that your net profit (the sum of the rewards you get minus the sum of the fees you pay) is at least k.", "answer": "Reduce the problem to the knapsack problem by defining the values and weights of the knapsack items in terms of the given variables.", "hint": "Think about how you can use the given variables to define the values and weights of the knapsack items.", "subproblem": [{"title": "Define the values of the knapsack items", "description": "For each animal, define the value of the knapsack item as the reward you get for taking it across the river minus the fee you have to pay if it gets attacked."}, {"title": "Define the weights of the knapsack items", "description": "For each animal, define the weight of the knapsack item as the cost of taking it across the river."}], "simplifiedAns": "In this problem, we are the captain of a ship and we need to transport animals across a river. However, some animals do not get along and may attack each other. If an animal gets attacked, we have to pay a fee to the owner, and if an animal makes it across the river without getting attacked, we receive a reward.\n\nOur goal is to find a subset of animals that we can take across the river in such a way that our net profit (rewards minus fees) is at least a certain value, denoted as k.\n\nTo solve this problem, we can reduce it to the knapsack problem. In the knapsack problem, we have a knapsack with a limited capacity, and we want to maximize the value of the items we can put into the knapsack without exceeding its capacity.\n\nIn our case, we can think of the animals as the items and their rewards and fees as their values and weights, respectively. The capacity of the knapsack represents the maximum net profit we want to achieve, which is k.\n\nBy defining the values and weights of the knapsack items in terms of the given variables, we can solve the knapsack problem to find the subset of animals that will maximize our net profit.\n\nTo do this, we assign the reward rj of each animal as its value, and the fee fj as its weight. We then use the knapsack algorithm to find the subset of animals that will give us the maximum net profit of at least k.\n\nBy solving the knapsack problem in this way, we can determine the optimal combination of animals to take across the river that will maximize our net profit and meet the required minimum value of k.\n\nAn analogy to understand this concept is to imagine that we have a limited amount of space in our backpack, and we want to pack items that will give us the highest total value without exceeding the weight limit. In this case, the animals are the items, their rewards are their values, and their fees are their weights. Our goal is to pack the animals that will give us the highest net profit without exceeding the maximum weight limit."}, {"question_id": "Spring2016_11", "topic": "Reductions, Bipartite Matching", "question_description": "Prove that Max 2SAT is NP-complete by reducing from 3SAT.", "answer": "Reduce the 3SAT instance to a Max 2SAT instance by constructing 10 clauses for each clause in the 3SAT instance.", "hint": "Think about how to reduce the 3SAT instance to a Max 2SAT instance.", "subproblem": [{"title": "Understand the 3SAT instance", "description": "Understand the 3SAT instance and its clauses."}, {"title": "Construct 10 clauses for each clause in the 3SAT instance", "description": "Construct 10 clauses for each clause in the 3SAT instance to reduce the 3SAT instance to a Max 2SAT instance."}], "simplifiedAns": "To prove that Max 2SAT is NP-complete, we need to show that any problem in the NP class can be reduced to Max 2SAT. In this case, we will reduce the 3SAT problem to Max 2SAT.\n\nThe 3SAT problem involves determining whether there exists an assignment of truth values to variables in a given Boolean formula, such that the formula evaluates to true. This problem is known to be NP-complete.\n\nTo reduce 3SAT to Max 2SAT, we will construct 10 clauses for each clause in the 3SAT instance. Let's understand this with an analogy:\n\nImagine you have a puzzle with 3 pieces that need to fit together perfectly to form a complete picture. Each piece has 3 sides, and each side has a specific shape that must match with the adjacent piece's side. This is similar to the 3SAT problem, where each clause has 3 literals that must satisfy certain conditions.\n\nNow, let's say we want to convert this puzzle into a different puzzle called Max 2SAT, where each piece has only 2 sides. To do this, we will create 10 new pieces for each original piece. Each new piece will have 2 sides that match the original piece's sides, and 8 additional sides that can be matched with other pieces.\n\nIn the context of the reduction, each clause in the 3SAT instance will be represented by 10 clauses in the Max 2SAT instance. These 10 clauses will be constructed in such a way that if the original 3SAT instance is satisfiable, the Max 2SAT instance will have a maximum number of satisfiable clauses.\n\nBy constructing these additional clauses, we ensure that the Max 2SAT instance has a solution if and only if the original 3SAT instance has a solution. This reduction shows that Max 2SAT is at least as hard as 3SAT, making it NP-complete.\n\nIn summary, we can prove that Max 2SAT is NP-complete by reducing the 3SAT problem to Max 2SAT. This reduction involves constructing 10 clauses for each clause in the 3SAT instance, ensuring that the Max 2SAT instance has a solution if and only if the original 3SAT instance has a solution."}, {"question_id": "Spring2016_12", "topic": "Greedy Algorithms", "question_description": "You are managing Fred's Fantastic Fruits delivery service. Your job is to choose which fruits to take to the market in your truck. You have n crates of fruit, each of which contains a different type of fruit. The ith crate holds ci fruits, each of which sells for pi at the market. Every fruit weighs 1 pound. Your truck can hold T pounds of fruit in total. Describe a greedy strategy to determine the optimal combination of fruits to take.", "answer": "Take the most expensive fruits until you run out of room.", "hint": "Think about how you can maximize the total profit while staying within the weight limit of the truck.", "subproblem": [{"title": "Calculate the total profit", "description": "Calculate the total profit of the fruits in each crate and sort them in descending order of profit."}, {"title": "Choose the fruits to take", "description": "Choose the fruits from the most profitable crates until the total weight of the fruits exceeds the weight limit of the truck."}], "simplifiedAns": "In managing Fred's Fantastic Fruits delivery service, our goal is to maximize our profit by choosing the best combination of fruits to take to the market. We have crates of different fruits, each with a certain quantity and selling price. Our truck has a weight limit, and each fruit weighs 1 pound.\n\nTo determine the optimal combination of fruits, we can use a greedy strategy. This means that at each step, we make the locally optimal choice that seems best at that moment, without considering the overall consequences.\n\nIn this case, our greedy strategy is to take the most expensive fruits until we run out of room in our truck. By selecting the most expensive fruits, we aim to maximize our profit per pound of fruit.\n\nLet's imagine this strategy with an analogy. Suppose you are going on a road trip and have limited space in your car trunk. You want to bring along the most valuable items to make the most profit if you decide to sell them during the trip. Each item has a different value, and you can only take a certain weight of items.\n\nTo optimize your profit, you would start by selecting the most valuable items and filling up your trunk until you reach the weight limit. This way, you ensure that you are carrying the most valuable items possible within the weight constraint.\n\nSimilarly, in our fruit delivery service, we prioritize the most expensive fruits because they have a higher selling price. By filling our truck with these high-value fruits until we reach the weight limit, we maximize our potential profit.\n\nTo implement this strategy, we would sort the crates of fruits in descending order based on their selling price. Then, we would start adding the fruits to our truck one by one, starting from the most expensive crate, until we reach the weight limit.\n\nBy following this greedy strategy, we can determine the optimal combination of fruits to take to the market, maximizing our profit per pound of fruit."}]