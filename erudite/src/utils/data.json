[{"question_id": "Fall_2021_7", "topic": "Dynamic Programming", "question_description": " The problem below is a dynamic programming problem and should be viewed as having 3 parts.You should find a function f which can be computed recursively so that evaluation of f on a certain input(or combining its evaluations on a few inputs) gives the answer to the stated problem.\u2022 Part (1) is to define f in words (without mention of how to compute it recursively). You should clearlystate how many parameters f has, what those parameters represent, what f evaluated on those pa-rameters represents, and how you should use f to get the answer to the stated problem.\u2022 Part (2) is to give a recurrence relation showing how to compute f recursively, including a descriptionof the base cases.\u2022 In part (3) you should give the running time and space for solving the original problem using com-putation of f via memoization or bottom-up dynamic programming. If you need to use certain datastructures, compute in a certain order, preprocess the data in a certain way, etc., to optimize computa-tion of f , you should say so.Note: if there are multiple solutions to solve the stated dynamic programming problem, you shoulddescribe the most time-efficient one you know. If there are multiple solutions with the same asymptotictime complexity, you should describe the implementation that gives the best asymptotic space complexity.The problem: A number is \u201cnice\u201d if each pair of adjacent digits in its decimal representation differ byat least 2. For example, \u201c13\u201d is nice, but \u201c28549\u201d isn\u2019t (the 5 and 4 only differ by one). Given k, calculatethe number of nice integers x that are k digits long. That is, calculate the number of nice x such that10k\u22121 \u2264 x \u2264 10k \u2212 1. You should output this number modulo P = 1000003.", "answer": "Let f (d, r) be the number of nice r digit numbers mod P that start with the digit d for some 0 \u2264 d \u2264 9. Then we will want to output (\u22119 d=1 f (d, k)) mod P. (b) To compute f , f (d, r) = ( 1, if r = 1 (\u2211d\u2032 :|d\u2212d\u2032 |\u22652 f (d\u2032, r \u2212 1)) mod P, if r > 1 (c) The running time is O(k). The space can be made O(1) by doing bottom up dynamic programming since f (\u00b7, r) values only depend on f (\u00b7, r \u2212 1) values.", "hint": "Start by understanding the problem and breaking it down into simpler subproblems. Think about how you can use the given function f to solve the problem.", "subproblem": [{"title": "Define f", "description": "Define the function f in words, including the number of parameters, what they represent, and what f evaluated on those parameters represents."}, {"title": "Recurrence relation", "description": "Give a recurrence relation showing how to compute f recursively, including a description of the base cases."}], "simplifiedAns": "Part (1):\nThe function f has two parameters: d and r. The parameter d represents the starting digit of a number, and the parameter r represents the number of digits in the number. Evaluating f on these parameters gives us the number of nice r-digit numbers that start with the digit d.\n\nTo solve the problem, we can use f to calculate the total number of nice k-digit numbers. We do this by summing up the values of f for all digits from 1 to 9, and then taking the result modulo P.\n\nPart (2):\nTo compute f recursively, we have two cases:\n- If r is equal to 1, then there is only one digit in the number. In this case, f(d, r) is equal to 1, as any single digit number is considered nice.\n- If r is greater than 1, we need to consider all possible digits d' that can follow the digit d. We sum up the values of f(d', r-1) for all d' such that the absolute difference between d and d' is at least 2. This represents the number of nice (r-1)-digit numbers that can follow the digit d. We take this sum modulo P to get f(d, r).\n\nPart (3):\nThe running time of this solution is O(k), as we need to compute f for each digit and each number of digits up to k.\n\nThe space complexity can be made O(1) by using bottom-up dynamic programming. Since the values of f only depend on the values of f for the previous number of digits, we can compute f iteratively and update the values in constant space.\n\nIn summary, we can solve the problem of finding the number of nice k-digit numbers by using the function f, which represents the number of nice r-digit numbers that start with a given digit. We compute f recursively using a recurrence relation, and then sum up the values of f for all digits to get the final result modulo P. The solution has a time complexity of O(k) and a space complexity of O(1) using bottom-up dynamic programming."}, {"question_id": "Fall_2021_8", "topic": "Dynamic Programming", "question_description": "Jack lives in Yaweno, where all the expressways between cities are one-way (i.e. directed edge).There are n cities and m expressways. Jack has ci friends living in city i, i \u2208 {1, . . . , n}. Jack lives in citys. Jack wants to go to city t. s, t \u2208 {1, . . . , n}. Given n, s, t and the m expressways between the n cities,Jack would like to calculate the maximum number of friends he can visit driving from s to t using onlyexpressways.(a) For this subpart only, suppose the expressways of Yaweno do not form any cycle (i.e. they form adirected acyclic graph). Give a three-part dynamic programming solution. The template is copiedbelow for your convenience.This problem is a dynamic programming problem and should be viewed as having 3 parts. Youshould find a function f which can be computed recursively so that evaluation of f on a certain input(or combining its evaluations on a few inputs) gives the answer to the stated problem.\u2022 Part (1) is to define f in words (without mention of how to compute it recursively). You shouldclearly state how many parameters f has, what those parameters represent, what f evaluated onthose parameters represents, and how you should use f to get the answer to the stated problem.\u2022 Part (2) is to give a recurrence relation showing how to compute f recursively, including a de-scription of the base cases.\u2022 In part (3) you should give the running time and space for solving the original problem usingcomputation of f via memoization or bottom-up dynamic programming. If you need to usecertain data structures, compute in a certain order, preprocess the data in a certain way, etc., tooptimize computation of f , you should say so.Note: if there are multiple solutions to solve the stated dynamic programming problem, you shoulddescribe the most time-efficient one you know. If there are multiple solutions with the same asymp-totic time complexity, you should describe the implementation that gives the best asymptotic spacecomplexity.", "answer": "(1) Let f (v) be the maximum number of friends Jack can visit starting from s and ending in v. Theanswer is then f (t). Alternatively, you could define f (v) to be the maximum number of friendsJack can visit starting from v and ending at t, and return f (s).(2) \u2022 Base Case: f (s) = cs, f (v) = \u2212\u221e \u2200v\u0338 = s.\u2022 Recurrence relation:f (v) = max(u,v)\u2208Ef (u) + cv.(3) \u2022 Time Complexity: Making a copy of the reversed edges takes O(m + n) time (assuming anadjacency list representation). Since we reversed all the edges of the graph, each vertex doesO(deg\u2212 v) work to find all the incoming edges, where deg\u2212 v denotes the indegree of v.Therefore the total runtime is O(m + n). Note: Even though each node has an indegree ofO(n), a bound of O(n2) is too loose by the amortized analysis above.\u2022 Space Complexity: Assuming a graph representation is given to us already, space complexityis O(n) because we need to store f (v) for all v \u2208 V.\u2022 Subproblem ordering: Traverse the vertices in topological order. Note: This level of detailwas not necessary for points, but in order to implement this, first topological sort the verticeswith a DFS. Next, either make a copy of the reversed edges of the graph to get the incomingedges of each vertex, or you can use the outgoing edges by iteratively updating f (u) =max( f (u), f (v) + cu) for each (v, u) \u2208 E . Then we can compute f (\u00b7) in topological order", "hint": "Start by understanding the problem and breaking it down into simpler subproblems. Think about how you can use dynamic programming to solve this problem.", "subproblem": [{"title": "Define the function f", "description": "Define a function f that takes in parameters and returns the maximum number of friends Jack can visit driving from s to t using only expressways."}, {"title": "Recurrence relation", "description": "Write a recurrence relation that shows how to compute f recursively, including a description of the base cases."}], "simplifiedAns": "In this problem, Jack wants to calculate the maximum number of friends he can visit while driving from city s to city t using only the expressways in Yaweno. We are given the number of cities n, the starting city s, the destination city t, and the expressways between the cities.\n\nTo solve this problem using dynamic programming, we can define a function f(v) which represents the maximum number of friends Jack can visit starting from s and ending in city v. The answer to the problem is then f(t).\n\nIn the base case, we set f(s) = cs, where cs represents the number of friends Jack has in city s. For all other cities v \u2260 s, we set f(v) = -\u221e (negative infinity).\n\nTo compute f(v) recursively, we iterate over all the expressways (u, v) that lead to city v. For each expressway, we calculate f(u) + cv, where cv represents the number of friends Jack has in city v. We take the maximum of all these values to get f(v).\n\nThe time complexity of this solution is O(m + n), where m is the number of expressways and n is the number of cities. This is because we need to iterate over all the expressways and perform constant time operations for each one. The space complexity is O(n) because we need to store f(v) for all v \u2208 V.\n\nTo optimize the computation of f, we can traverse the vertices in topological order. This means that we process the cities in an order such that for every expressway (u, v), city u is processed before city v. This ensures that we have already computed f(u) before we need it to compute f(v).\n\nTo implement this, we can first topologically sort the vertices using a depth-first search (DFS). Then, we can either make a copy of the reversed edges of the graph to get the incoming edges of each vertex, or we can use the outgoing edges and iteratively update f(u) = max(f(u), f(v) + cv) for each (v, u) in the expressways. Finally, we can compute f(\u00b7) in topological order.\n\nOverall, this dynamic programming solution allows us to efficiently calculate the maximum number of friends Jack can visit while driving from city s to city t in Yaweno, given the constraints of the problem."}, {"question_id": "Spring_2021_4", "topic": "Dynamic Programming", "question_description": "You are running Toasty Digits, a company that produces mittens. To make sure that your company canmeet demands, you are planning out the production for the coming n months. The following informationis given to you:\u2022 Demand: In month i, the demand will be di \u2265 0 (i.e. you sell exactly di pairs of mittens in month i).The total demand for all n months is given by D = \u2211ni=1 di.\u2022 Production: Your full-time knitting staff can produce at most m pairs of mittens per month. You canhire additional knitters who will produce as many additional mittens as you need, but at a cost of cdollars per pair (whereas you do not pay anything per pair for your full-time staff).\u2022 Storage: If, at the end of a month, you have any leftover mittens, you have to store them at a cost. Inparticular, if you have k pairs of mittens left, you pay hk \u2265 0 dollars. You can store at most D pairs ofmittens.Provide a dynamic programming algorithm for computing the minimum total cost required to meet alldemand. Your solution should include the following:(a) A description of your subproblems and how you will use them to compute the final answer.Hint: Let one of the subproblem parameters be the number of leftover mittens.(b) A recurrence relation for your subproblems and the relevant base cases.(c) A justification for your recurrence relation and your base cases.(d) The order in which to solve the subproblems.(e) The runtime of solving all subproblems and computing the final answer.", "answer": "(a) We will define the subproblem f (i, r) as the minimum cost to get to the end of month i, having satisfiedall demand so far, with r pairs of mittens left over. The final answer will be f (n, 0): the subproblemcorresponding to month n with 0 mittens left.(b) The recurrence is given byf (i, r) = min0\u2264p\u2264r+diF(i, r, p)where F(i, r, p) is the cost incurred during month i if we start it with p pairs of mittens and end it withr pairs left:F(i, r, p) ={hp + f (i \u2212 1, p) if m \u2265 r + di \u2212 php + c(r + di \u2212 p \u2212 m) + f (i \u2212 1, p)The base cases are f (0, \u00b7) = \u221e, except for f (0, 0) = 0(c) The base cases follow because at the beginning of month 1, we have zero mittens. This makes f (0, 0)the actual starting point and all other f (0, \u00b7) impossible.The recurrence follows because we want to minimize the cost given the number of mittens we haveleft over after each month. The cost for each month depends on the demand and the number ofmittens we have left over and the number we want to have left over. Furthermore, if we have p mittensleft over from the month before, we always pay hp. Furthermore, we need to consider whatever wehave paid so far. Finally, if our full-time staff cannot knit enough mittens to cover demand and thenumber of mittens we want to have left over, even using the previous stock, we must hire outsidestaff at cost c per pair.(d) The order of the subproblems need not depend on the number of mittens left, but we need to solve interms of increasing months, i.e. f (i \u2212 1, r) before f (i, m) for all r, m.(e) We have O(nD) subproblems and each subproblem takes O(D) time to compute. Hence, the runtimeis O(nD2).", "hint": "Think about the cost incurred in each month and how it depends on the demand and the number of mittens left over.", "subproblem": [{"title": "Define the subproblem", "description": "Define the subproblem f (i, r) as the minimum cost to get to the end of month i, having satisfied all demand so far, with r pairs of mittens left over."}, {"title": "Recurrence relation and base cases", "description": "Write a recurrence relation for the subproblem and the relevant base cases."}], "simplifiedAns": "Toasty Digits is a company that produces mittens. In order to meet the demands of their customers, they need to plan out their production for the coming months. They have information about the demand for each month, the production capacity of their full-time staff, and the cost of hiring additional knitters. They also need to consider the cost of storing any leftover mittens at the end of each month.\n\nTo solve this problem, we can use dynamic programming. We define a subproblem as the minimum cost required to meet the demand up to a certain month, while also considering the number of leftover mittens. The final answer will be the minimum cost to meet all the demand.\n\nThe recurrence relation for the subproblems is as follows: \nf(i, r) = min(0 \u2264 p \u2264 r+di) { hp + f(i-1, p) if m \u2265 r+di - p, hp + c(r+di-p-m) + f(i-1, p) }\n\nLet's break down this recurrence relation. For each month i, we consider all possible values of p, which represents the number of mittens we start the month with. We calculate the cost incurred during month i based on the number of mittens we start with, the number of mittens we want to have left over, and the demand for that month.\n\nIf our full-time staff can produce enough mittens to meet the demand and the number of mittens we want to have left over, we don't need to hire additional knitters. In this case, the cost is simply the storage cost for the leftover mittens from the previous month, plus the cost of storing any additional leftover mittens at the end of the current month.\n\nHowever, if our full-time staff cannot meet the demand and the desired number of leftover mittens, we need to hire additional knitters. In this case, the cost includes the hiring cost for the additional mittens, as well as the storage cost for any leftover mittens from the previous month and any additional leftover mittens at the end of the current month.\n\nThe base cases for the subproblems are f(0, \u00b7) = \u221e, except for f(0, 0) = 0. This means that at the beginning of month 1, we have zero mittens, so the cost is 0. All other base cases are impossible because we cannot have leftover mittens without any previous months.\n\nTo solve the subproblems, we need to iterate through the months in increasing order and calculate the minimum cost for each subproblem. This ensures that we have the necessary information from previous months to calculate the cost for the current month.\n\nThe runtime of solving all the subproblems and computing the final answer is O(nD^2), where n is the number of months and D is the total demand for all the months. We have O(nD) subproblems, and each subproblem takes O(D) time to compute.\n\nIn summary, the dynamic programming algorithm helps Toasty Digits minimize the cost required to meet the demand for mittens. By considering the number of leftover mittens and the production capacity, the algorithm determines the optimal production plan and hiring decisions. This ensures that the company can meet customer demands efficiently while minimizing costs."}]